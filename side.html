<html>
<head>
	<meta charset="utf-8">
    <title>Side</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }
        canvas {
			margin: auto;
			display: block;
			margin-top: 50px;
		}
    </style>
    <script src="pixi.js"></script>
    <script src="keyboard.js"></script>
    <script src="level0MapData.js"></script>
</head>
<body>
    <script>
		
		var Defaults = {
			backgroundLayersSize: [1024, 512],
			backgroundLayers: {
				sky: {speed: 0.1, offsetY: 0},
				far: {speed: 0.2, offsetY: 64},
				near: {speed: 0.55, offsetY: 128}
			},
			scrollSpeed: 5,
			
			stageSize: [12, 10],
			stageMap: {
				mapSize: [16, 10],
				unitSize: [64, 64],
				mapRepository: level0MapRepository,
				mapData: level0MapData
			},
			
			viewportPosition: {x: 0, y: 0},
			playerStart: {x: 2, y: 5},
			playerSpeed: 5
		};
		
		var Utils = {
			expandToXY: function(number, sizeX) {
				var y = Math.floor(number / sizeX);
				return {x: number - y * sizeX, y: y};
			},
			
			mapPositionToCoordinates: function(mapPosition) {
				return {
					x: mapPosition.x * Defaults.stageMap.unitSize[0],
					y: mapPosition.y * Defaults.stageMap.unitSize[1]
				};
			},
			
			coordinatesToMapPosition: function(coordinates) {
				return {
					x: Math.floor(coordinates.x / Defaults.stageMap.unitSize[0]),
					y: Math.floor(coordinates.y / Defaults.stageMap.unitSize[1])
				};
			}
		};
		
		var Viewport = function(position) {
			this.position = position;
			this.tracked_objects = [];
			
			this.direction = {x: 0, y: 0};
			this.speed = Defaults.scrollSpeed;
		}
		
		Viewport.prototype.setX = function(newViewportX) {
			for(var i = 0; i < this.tracked_objects.length; i++) {
				var distanceTravelled = newViewportX - this.position.x;
				
				var speed = 1;
				var obj_name = this.tracked_objects[i].name || null;
				
				if( obj_name && Defaults.backgroundLayers[obj_name] ) {
					speed = Defaults.backgroundLayers[obj_name].speed;
				}
				
				if( this.tracked_objects[i].tilePosition ) {
					this.tracked_objects[i].tilePosition.x -= (distanceTravelled * speed);
				} else {
					this.tracked_objects[i].position.x -= (distanceTravelled * speed);
				}
			}
			this.position.x = newViewportX;
		}
		
		Viewport.prototype.setY = function(newViewportY) {
			for(var i = 0; i < this.tracked_objects.length; i++) {
				var distanceTravelled = newViewportY - this.position.y;
				
				var speed = 1;
				var obj_name = this.tracked_objects[i].name || null;
				
				if( obj_name && Defaults.backgroundLayers[obj_name] ) {
					continue;
					speed = Defaults.backgroundLayers[obj_name].speed;
				}
				
				if( this.tracked_objects[i].tilePosition ) {
					this.tracked_objects[i].tilePosition.y -= (distanceTravelled * speed);
				} else {
					this.tracked_objects[i].position.y -= (distanceTravelled * speed);
				}
			}
			this.position.y = newViewportY;
		}
		
		Viewport.prototype.getX = function() {
			return this.position.x;
		}
		
		Viewport.prototype.getY = function() {
			return this.position.y;
		}
		
		Viewport.prototype.moveX = function(units) {
			var newX = this.getX() + units;
			this.setX(newX);
		}
		
		Viewport.prototype.moveY = function(units) {
			var newY = this.getY() + units;
			if( newY > 0 ) return;
			this.setY(newY);
		}
		
		Viewport.prototype.track = function(objectToTrack) {
			this.tracked_objects.push(objectToTrack);
		}
		
		Viewport.prototype.update = function() {
			this.moveX(this.speed * this.direction.x);
			this.moveY(this.speed * this.direction.y);
		}
		
		viewport = new Viewport(Defaults.viewportPosition);
		
		
		/* Containers */
		var BackgroundScroller = function(stage) {
			
			this.backgroundLayers = {};
			
			for(var tex in Defaults.backgroundLayers) {
				this.backgroundLayers[tex] = new BackgroundLayer(tex);
				viewport.track(this.backgroundLayers[tex]);
				stage.addChild( this.backgroundLayers[tex] );
			}
		}
		
		var LevelMap = function(stage) {
			
			this.repository = Defaults.stageMap.mapRepository;
			this.textures = {};
			
			/* Load level map textures */
			for(var i in this.repository) {
				if( this.repository[i] === null ) { continue; }
				
				var pathToTexture = this.repository[i];
				this.textures[i] = PIXI.Texture.fromImage(pathToTexture);
			}
			
			this.levelTiles = [];
			
			/* Add level tiles to stage */
			for(var i = 0; i < Defaults.stageMap.mapSize[0] * Defaults.stageMap.mapSize[1]; i++) {
				var tileIndex = Defaults.stageMap.mapData[i];
				
				if( this.repository[tileIndex] !== null ) {
					this.levelTiles[i] = new MapTile(i, this.textures[tileIndex]);
					
					viewport.track(this.levelTiles[i]);
					stage.addChild( this.levelTiles[i] );
				} else {
					this.levelTiles[i] = null;
				}
			} 
		}
		
		/* Display Objects */
		var BackgroundLayer = function(backgroundName) {
			
			this.name = backgroundName;
			
			var pathToTexture = 'background-'+this.name+'.png';
			var texture = PIXI.Texture.fromImage(pathToTexture);
			
			PIXI.TilingSprite.call(this, texture, Defaults.backgroundLayersSize[0], Defaults.backgroundLayersSize[1]);
			
			this.position.x = 0;
			this.position.y = Defaults.backgroundLayers[backgroundName].offsetY;
			this.tilePosition.x = 0;
			this.tilePosition.y = 0;
			
			this.speed = Defaults.backgroundLayers[backgroundName].speed;
		}
		
		BackgroundLayer.constructor = BackgroundLayer;
		BackgroundLayer.prototype = Object.create(PIXI.TilingSprite.prototype);
		
		var MapTile = function(mapIndex, texture) {
			this.mapIndex = mapIndex;
			this.tileIndex = Defaults.stageMap.mapData[this.mapIndex];
			
			PIXI.Sprite.call(this, texture);
			
			this.mapPosition = Utils.expandToXY(this.mapIndex, Defaults.stageMap.mapSize[0]);
			this.position = Utils.mapPositionToCoordinates(this.mapPosition);
		}
		
		MapTile.constructor = MapTile;
		MapTile.prototype = Object.create(PIXI.Sprite.prototype);
		
		var PlayerSprite = function() {
			
			texture = PIXI.Texture.fromImage('character.png');
			PIXI.Sprite.call(this, texture);
			
			this.mapPosition = Defaults.playerStart;
			this.position = Utils.mapPositionToCoordinates(this.mapPosition);
			
			this.anchor.y = 0.2;
			
			this.speed = Defaults.playerSpeed;
			this.direction = {x: 0, y: 0};
			
			this.action = "idle";
			this.oldAction = this.action;
			
			this.action_timer = 0;
			
			viewport.track(this);
		}
		
		PlayerSprite.constructor = PlayerSprite;
		PlayerSprite.prototype = Object.create(PIXI.Sprite.prototype);
		
		PlayerSprite.prototype.setX = function(newPX) {
			this.position.x = newPX;
			this.mapPosition = Utils.coordinatesToMapPosition(this.position);
		}
		
		PlayerSprite.prototype.setY = function(newPY) {
			this.position.y = newPY;
			this.mapPosition = Utils.coordinatesToMapPosition(this.position);
		}
		
		PlayerSprite.prototype.getX = function() {
			return this.position.x;
		}
		
		PlayerSprite.prototype.getY = function() {
			return this.position.y;
		}
		
		PlayerSprite.prototype.moveX = function(units) {
			var newX = this.getX() + units;
			this.setX(newX);
		}
		
		PlayerSprite.prototype.moveY = function(units) {
			var newY = this.getY() + units;
			this.setY(newY);
		}
		
		PlayerSprite.prototype.setAction = function(action) {
			this.oldAction = this.action;
			this.action = action;
			
			if( this.oldAction != this.action ) {
				this.action_timer = 0;
			}
		}
		
		PlayerSprite.prototype.getAction = function() {
			return this.action;
		}
		
		PlayerSprite.prototype.isOnFloor = function(levelMap) {
			if( levelMap.levelTiles[this.mapPosition.x + (this.mapPosition.y + 1) * Defaults.stageSize[0]] === null ) {
				return false;
			}
			var lastGoodPosition = Utils.mapPositionToCoordinates(this.mapPosition);
			var yDiff = this.position.y - lastGoodPosition.y;
				
			this.position.y -= yDiff;
				
			return true;
		}
		
		PlayerSprite.prototype.update = function(levelMap) {
			// Init handling
			if( this.getAction() == "idle" )
				this.setAction("fall");
			
			// FMS
			switch( this.getAction() ) {
				case "idle": /* do nothing */ break;
				case "jump":
					if( this.action_timer == 0 ) {
						this.velocityY = 10;
					}
					this.moveY(- this.velocityY);
					this.velocityY -= 0.5;
					
					if( this.isOnFloor(levelMap) ) {
						this.setAction('idle');
					}
					
					break;
				case "fall":
					if( this.action_timer == 0 ) {
						this.velocityY = 10;
					}
					this.moveY(this.velocityY);
					
					if( this.isOnFloor(levelMap) ) {
						this.setAction('idle');
					}
					
					break;
			}
			
			this.action_timer += 0.1;
			
			// Proper movement
			this.moveX(this.speed * this.direction.x);
		}
		
		/* Init game elements */
		var stage = new PIXI.Stage(0xFFF);
		var renderer = PIXI.autoDetectRenderer(
			Defaults.stageSize[0] * Defaults.stageMap.unitSize[0],
			Defaults.stageSize[1] * Defaults.stageMap.unitSize[1]
		);
		document.body.appendChild(renderer.view);
	 
		var bgScroller = new BackgroundScroller(stage);
		var levelMap = new LevelMap(stage);
		var player = new PlayerSprite();
		stage.addChild( player );
		
		/* Keyboard handling */
		KeyboardJS.on("right", function() {
			viewport.direction.x = 1;
			player.direction.x = 1;
		}, function() {
			if( viewport.direction.x === 1 ) {
				viewport.direction.x = 0;
			}
			if( player.direction.x === 1 ) {
				player.direction.x = 0;
			}
		});
		
		KeyboardJS.on("left", function() {
			viewport.direction.x = -1;
			player.direction.x = -1;
		}, function() {
			if( viewport.direction.x === -1 ) {
				viewport.direction.x = 0;
			}
			if( player.direction.x === -1 ) {
				player.direction.x = 0;
			}
		});
		
		KeyboardJS.on("up", function() {
			if( player.getAction() != "fall" ) {
				player.setAction("jump");
			}
			
		}, function() {
			
		});
		
		/* Start game loop */
		requestAnimFrame( animate );
	 
		function animate() {
			requestAnimFrame( animate );

			viewport.update();
			
			player.update(levelMap);
			
			renderer.render(stage);
		}
 
    </script>
 
    </body>
</html>
